# HyperDash - Design Rules & Guidelines

## IMPORTANT: Rules File Maintenance

**After making any changes to the codebase, ALWAYS ask the user:**
"Do you want me to update the .cursorrules file with any new patterns, conventions, or SOPs that were established?"

This ensures the rules file stays current with evolving project standards and helps maintain consistency across the codebase.

## Project Overview
A reactive personal dashboard webapp. Built with Next.js 15, TypeScript, Tailwind CSS, and React.

## Color Scheme

### Reactive Color System

**IMPORTANT**: Text colors are now dynamically reactive to the wallpaper background. The system analyzes wallpaper brightness and adjusts the green color palette accordingly for optimal contrast and readability.

**How it works:**
- Wallpaper brightness is analyzed when a wallpaper is uploaded or changed
- Color adjustments are calculated based on brightness:
  - Dark wallpapers (brightness < 0.3): Increase text brightness by 20-30% for better contrast
  - Medium wallpapers (0.3-0.7): Minimal adjustment
  - Light wallpapers (brightness > 0.7): Decrease text brightness by 15-25% for better contrast
- Colors are stored in React Context and persisted to localStorage
- CSS custom properties are set for global access (especially for placeholders)

**Color Palette Structure:**
- **primary**: Main content text (equivalent to green-300, dynamically adjusted)
- **secondary**: Labels, headings, secondary information (equivalent to green-400, dynamically adjusted)
- **placeholder**: Input placeholders (equivalent to green-500/80, dynamically adjusted)
- **muted**: Completed/strikethrough items (equivalent to green-600, dynamically adjusted)
- **button**: Button labels (equivalent to green-300, dynamically adjusted)

**Default Colors (fallback):**
- Primary: `rgb(134, 239, 172)` (green-300)
- Secondary: `rgb(74, 222, 128)` (green-400)
- Placeholder: `rgba(34, 197, 94, 0.8)` (green-500/80)
- Muted: `rgb(22, 163, 74)` (green-600)
- Button: `rgb(134, 239, 172)` (green-300)

### Text Colors (Primary)
**NOTE**: Use `useReactiveColors()` hook instead of hardcoded Tailwind classes for text colors.

- **Primary Text**: Use `colors.primary` from `useReactiveColors()` hook - Main content text
- **Labels/Secondary Text**: Use `colors.secondary` - Labels, headings, secondary information
- **Placeholder Text**: Use `colors.placeholder` - Input placeholders (automatically styled via CSS)
- **Muted Text**: Use `colors.muted` - Only for completed/strikethrough items (intentionally muted)
- **Button Text**: Use `colors.button` - Button labels

### Borders (Unified Neutral)
- **Default Border**: `border-white/20` - All widget borders, input fields, buttons
- **Hover Border**: `border-white/50` - More visible on hover
- **Focus Border**: `border-white/50` - Input focus states
- **Internal Dividers**: `border-white/10` - Subtle dividers within widgets
- **NO COLORED BORDERS** - All borders must be white/neutral to be reactive to wallpaper

### Backgrounds
- **Widget Background**: `bg-black/40` - Semi-transparent with backdrop blur
- **Input Fields**: `bg-black/10` - Subtle background for inputs
- **Buttons**: `bg-white/10` - Default button background
- **Button Hover**: `bg-white/15` - Hover state
- **Modal Background**: `bg-black/40 backdrop-blur-xl` - Same as widgets

### Shadows
- **Widget Shadow**: Standard dark shadow with subtle inset highlight
- **Button Shadow**: `hover:shadow-white/20` - White glow on hover
- **Input Shadow**: `inset 0 1px 2px rgba(0, 0, 0, 0.3)` - Subtle inset shadow

### Scrollbar
- **Thumb**: `rgba(255, 255, 255, 0.2)` - Neutral white
- **Thumb Hover**: `rgba(255, 255, 255, 0.4)` - More visible on hover

## Modular Widget System Architecture

### Three-Layer System

HyperDash uses a three-layer modular architecture for widgets:

1. **Dashboard Layer** (`app/components/Dashboard.tsx`)
   - Top-level component that manages widget configuration
   - Loads configuration from localStorage on mount
   - Calculates layout slots from configuration
   - Maps widget positions to containers dynamically
   - Handles widget-specific props through `getWidgetProps()` function
   - Maintains grid layout structure (currently 3+2, but derived from configuration)

2. **Widget Container Layer** (`app/components/WidgetContainer.tsx`)
   - Position slots (1-5) that conditionally render widgets
   - Lazy loads widget components using React.lazy() and Suspense
   - Only loads widgets when assigned to a slot (code splitting)
   - Handles empty slots (when widgetType is null)
   - Adds `id` and `data-widget-position` attributes for future keyboard shortcuts
   - Shows loading state while widgets load

3. **Widget Layer** (`app/components/[WidgetName]Widget.tsx`)
   - Individual widget components in separate files
   - Each widget is code-split into its own chunk
   - Only loaded when assigned to a slot
   - Receives props from Dashboard through WidgetContainer
   - Uses base `Widget` component for consistent styling

### Widget Registry System

**File**: `app/lib/widgetRegistry.ts`

The widget registry maps widget types to dynamic import paths for code splitting:

- **WidgetType**: Union type defining available widget types: `'clock' | 'weather' | 'system' | 'todo' | 'notepad'`
- **Dynamic Import Registry**: Maps widget types to import functions
- **Code Splitting**: Each widget becomes its own chunk, only loaded when needed
- **Type Safety**: TypeScript ensures only valid widget types are used

**Key Functions:**
- `loadWidget(type: WidgetType)`: Dynamically loads a widget component
- `isValidWidgetType(type: string)`: Type guard for widget type validation
- `getAvailableWidgetTypes()`: Returns array of all available widget types

**Adding New Widget Types:**
1. Add widget type to `WidgetType` union type
2. Add dynamic import entry to `widgetComponents` registry
3. Create widget component file in `app/components/`
4. Register in WidgetContainer's `lazyWidgets` object

### Widget Configuration System

**File**: `app/lib/widgetConfig.ts`

The configuration system manages widget positions and assignments:

- **WidgetSlot Interface**: `{ position: number, widgetType: WidgetType | null }`
  - `position`: Slot number (1-5, or more in future)
  - `widgetType`: Widget type assigned to slot, or `null` for empty slot
- **WidgetConfiguration Type**: Array of `WidgetSlot` objects
- **localStorage Persistence**: Configuration stored under key `'hyperdash-widget-config'`
- **Default Configuration**: Positions 1-5 mapped to Clock, Weather, System, Todo, Notepad

**Key Functions:**
- `getWidgetConfiguration()`: Loads config from localStorage or returns default
- `saveWidgetConfiguration(config)`: Saves config to localStorage
- `getWidgetByPosition(position)`: Gets slot by position number
- `getWidgetsSortedByPosition()`: Returns slots sorted by position
- `getLayoutSlots(config)`: Calculates topRow and bottomRow from configuration
  - Positions 1-3 → top row (3 columns)
  - Positions 4-5 → bottom row (2 columns)
  - Fills empty slots if needed

**Configuration Structure:**
```typescript
const config: WidgetConfiguration = [
  { position: 1, widgetType: 'clock' },
  { position: 2, widgetType: 'weather' },
  { position: 3, widgetType: 'system' },
  { position: 4, widgetType: 'todo' },
  { position: 5, widgetType: 'notepad' },
];
```

### WidgetContainer Component

**File**: `app/components/WidgetContainer.tsx`

The WidgetContainer component handles lazy loading and rendering of widgets:

**Props:**
- `position: number` - Position slot number (1-5)
- `widgetType: WidgetType | null` - Widget type or null for empty slot
- `widgetProps?: Record<string, any>` - Props to pass to widget

**Implementation Details:**
- Uses `React.lazy()` at module level for each widget type
- Wraps widget in `Suspense` boundary with loading fallback
- Renders empty container div if `widgetType` is null
- Adds `id={`widget-${position}`}` for future keyboard shortcuts
- Adds `data-widget-position={position}` attribute for querying

**Lazy Loading Pattern:**
```tsx
const lazyWidgets: Record<WidgetType, React.LazyExoticComponent<...>> = {
  clock: lazy(() => import('../components/ClockWidget')),
  weather: lazy(() => import('../components/WeatherWidget')),
  // ... etc
};
```

**Empty Slot Handling:**
- Empty slots render as empty div containers
- Ready for future drag-and-drop UI
- Prevents unnecessary API calls/data fetching

### Widget Props Management

**Dashboard Integration** (`app/components/Dashboard.tsx`):

The Dashboard component manages widget-specific props through a mapping function:

```tsx
const getWidgetProps = (widgetType: WidgetType | null, position: number) => {
  if (widgetType === 'weather') {
    return { onLoadComplete: handleWeatherLoadComplete };
  }
  return {};
};
```

**Pattern:**
- Widgets that need Dashboard-level callbacks receive them via props
- Props are passed through WidgetContainer to the lazy-loaded widget
- Allows widgets to communicate with Dashboard (e.g., loading states, events)

### Position-Based Layout Rules

**Position Numbering:**
- Positions are numbered **left-to-right, top-to-bottom**
- Current layout: Positions 1-3 = top row, Positions 4-5 = bottom row
- Positions are independent of widget types (any widget can go in any slot)

**Layout Calculation:**
- `getLayoutSlots()` function maps positions to rows
- Top row: positions 1-3 (always 3 slots)
- Bottom row: positions 4-5 (always 2 slots)
- Empty slots are filled if configuration is incomplete
- Future: Layout structure will be configurable (e.g., 2+3, 4+1, etc.)

**Position Assignment:**
- Each widget slot has a unique position number
- Widgets can be reassigned to different positions
- Empty slots have `widgetType: null`
- Configuration persists across sessions via localStorage

**Future Keyboard Shortcuts:**
- Each widget container has `id={`widget-${position}`}`
- Enables keyboard shortcuts (1-5 keys) to focus widgets
- `data-widget-position` attribute for easy querying

## Component Structure

### Widget Component
All widgets use the base `Widget` component:
- Unified white border (`border-white/20`)
- Semi-transparent background (`bg-black/40 backdrop-blur-xl`)
- Hover effects:
  - Border transitions to `border-white/50`
  - Subtle upward lift (`hover:-translate-y-[1px]`)
  - Enhanced shadow (`hover:shadow-xl`)
  - Smooth 300ms transition (`transition-all duration-300`)
- Title with `border-white/10` divider
- Flex column layout with proper height constraints

### Layout Structure
- **Position-Based System**: Widgets are assigned positions 1-5 (left-to-right, top-to-bottom)
  - Positions 1-3: Top row (33.33% height, 3 equal columns)
  - Positions 4-5: Bottom row (66.66% height, 2 columns, 50/50 split)
- **Configurable Layout**: Widget positions are stored in localStorage and can be reordered
- **Default Configuration**: Clock (1), Weather (2), System (3), Todo (4), Notepad (5)
- Grid layout with proper height constraints (`flex-1 min-h-0`)
- Future: Layout structure will be fully configurable via UI

### Widget-Specific Patterns

#### Todo Widget
- Input field with `border-white/20`, focus: `border-white/50`
- Add button with neutral white styling
- Todo items with `border-white/10`, hover: `border-white/30`
- Checkbox accent: `accent-green-400` (matches text scheme)
- Delete button: `text-green-400`, hover: `text-green-300`
- **Drag-and-drop reordering**: 
  - Drag handle (grid of dots SVG) positioned to the left of delete button
  - Real-time visual reordering as you drag (items shift position immediately)
  - Browser drag ghost image is hidden using transparent canvas
  - Uses `draggedId` and `dragOverId` state for tracking
  - `getDisplayTodos()` function calculates visual order during drag

#### Notepad Widget
- Textarea with `border-white/20`, focus: `border-white/50`
- Scrollable content area with `overflow-y-auto min-h-0`

#### System Info Widget
- Labels: `text-green-400`
- Values: `text-green-300`
- Settings button: Neutral white styling
- Modal: Same styling as widgets

## Styling Conventions

### Border Rules
1. **NEVER use colored borders** (pink, blue, cyan, green for borders)
2. Always use `border-white/[opacity]` for consistency
3. Default: `border-white/20`
4. Hover/Focus: `border-white/50`
5. Internal dividers: `border-white/10`

### Background Rules
1. Widgets: `bg-black/40` with `backdrop-blur-xl`
2. Inputs: `bg-black/10`
3. Buttons: `bg-white/10`
4. Always use semi-transparent backgrounds for blur effect

### Text Rules
1. **NEVER use hardcoded Tailwind green color classes** (e.g., `text-green-300`, `text-green-400`)
2. **ALWAYS use `useReactiveColors()` hook** to access reactive color palette
3. Apply colors via inline styles: `style={{ color: colors.primary }}`
4. Primary content: `colors.primary`
5. Labels/secondary: `colors.secondary`
6. Placeholders: `colors.placeholder` (automatically styled via CSS custom properties)
7. Muted (completed items): `colors.muted`
8. Buttons: `colors.button`

### Spacing & Layout
- Use `flex-1 min-h-0` for scrollable containers
- Use `overflow-hidden` on parent containers to constrain children
- Padding: `p-4` for widgets, `p-3` for inputs
- Gap: `gap-4` between widgets, `gap-2` for internal spacing

## Widget Requirements

### All Widgets Must:
1. Use the base `Widget` component (no custom border colors)
2. Have proper height constraints for scrolling when needed
3. Use consistent text color hierarchy
4. Have neutral white borders (reactive to wallpaper)
5. Support hover effects (automatic via base Widget component):
   - Border transition to `border-white/50`
   - Subtle upward lift of 1px
   - Enhanced shadow
   - Smooth 300ms transition

### Input Fields Must:
1. Use `border-white/20` default
2. Use `border-white/50` on focus
3. Use `style={{ color: colors.primary }}` for text color (from `useReactiveColors()`)
4. Placeholder color is automatically handled via CSS custom property `--text-placeholder`
5. Have `bg-black/10` background
6. Include proper inset shadows

### Buttons Must:
1. Use `bg-white/10` background
2. Use `border-white/30` border
3. Use `style={{ color: colors.button }}` for text color (from `useReactiveColors()`)
4. Hover: `bg-white/15`, `border-white/50`
5. Include subtle shadows

## File Structure
```
app/
  components/
    Widget.tsx          # Base widget component
    Dashboard.tsx       # Main layout, manages widget configuration
    WidgetContainer.tsx # Container component for lazy loading widgets
    ColorContext.tsx    # Reactive color context provider
    ClockWidget.tsx
    WeatherWidget.tsx
    SystemInfoWidget.tsx
    TodoWidget.tsx
    NotepadWidget.tsx
  lib/
    widgetRegistry.ts   # Widget type definitions and dynamic import registry
    widgetConfig.ts     # Widget configuration management and layout helpers
    utils.ts            # localStorage helpers
    colorUtils.ts       # Wallpaper analysis and color calculation
  globals.css           # Global styles, scrollbar, CSS custom properties
```

## Key Principles

1. **Wallpaper Reactive**: 
   - All borders use white/neutral colors that adapt to background via backdrop blur
   - Text colors dynamically adjust based on wallpaper brightness for optimal contrast
2. **Consistency**: Unified color scheme across all widgets
3. **Visibility**: Text colors automatically adapt for readability on any wallpaper
4. **Modern Aesthetic**: Monospace fonts, thin borders, semi-transparency, backdrop blur
5. **Accessibility**: Good contrast ratios while maintaining aesthetic, automatically optimized per wallpaper

## Reactive Color System

### Implementation Details

**Files:**
- `app/lib/colorUtils.ts`: Contains wallpaper analysis and color calculation functions
- `app/components/ColorContext.tsx`: React context provider for reactive colors
- `app/globals.css`: CSS custom properties for global color access

**Usage in Components:**
```tsx
import { useReactiveColors } from './ColorContext';

export default function MyWidget() {
  const { colors } = useReactiveColors();
  
  return (
    <div style={{ color: colors.primary }}>
      <h2 style={{ color: colors.secondary }}>Title</h2>
      <input style={{ color: colors.primary }} />
      {/* Placeholder automatically styled via CSS */}
    </div>
  );
}
```

**Color Calculation Algorithm:**
1. Wallpaper image is analyzed using canvas API (downsampled for performance)
2. Average brightness is calculated using weighted formula: `(R * 0.299 + G * 0.587 + B * 0.114) / 255`
3. Brightness is normalized to 0-1 scale
4. Adjustment factor is calculated:
   - Dark (< 0.3): factor = 1 + (0.3 - brightness) * 0.8
   - Medium (0.3-0.7): factor = 1.0
   - Light (> 0.7): factor = 1 - (brightness - 0.7) * 0.6
5. RGB values are adjusted while maintaining hue (green theme preserved)

**CSS Custom Properties:**
- `--text-primary`: Set dynamically by ColorContext
- `--text-secondary`: Set dynamically by ColorContext
- `--text-placeholder`: Set dynamically by ColorContext (used for input/textarea placeholders)
- `--text-muted`: Set dynamically by ColorContext
- `--text-button`: Set dynamically by ColorContext

**Persistence:**
- Reactive colors are saved to localStorage when wallpaper changes
- Colors are restored on page load if wallpaper exists
- Default colors used if no wallpaper or analysis fails

## Adding New Widgets

When adding new widgets, follow this complete process:

### Step 1: Create Widget Component
1. Create new widget file: `app/components/[WidgetName]Widget.tsx`
2. Use the base `Widget` component (no `borderColor` prop)
3. Follow the unified white border scheme
4. **Import and use `useReactiveColors()` hook** to access dynamic colors
5. Apply colors via inline styles: `style={{ color: colors.primary }}`
6. **NEVER use hardcoded Tailwind green classes** (text-green-300, etc.)
7. Ensure proper height constraints for scrolling if needed
8. Match button and input styling patterns
9. Test hover states for visibility
10. Placeholder colors are handled automatically via CSS

### Step 2: Register Widget Type
1. Open `app/lib/widgetRegistry.ts`
2. Add widget type to `WidgetType` union type: `'clock' | 'weather' | 'system' | 'todo' | 'notepad' | 'yourwidget'`
3. Add dynamic import entry to `widgetComponents` registry:
   ```typescript
   yourwidget: () => import('../components/YourWidgetWidget'),
   ```

### Step 3: Register in WidgetContainer
1. Open `app/components/WidgetContainer.tsx`
2. Add lazy import entry to `lazyWidgets` object:
   ```typescript
   yourwidget: lazy(() => import('../components/YourWidgetWidget')),
   ```

### Step 4: Add to Configuration (Optional)
1. Open `app/lib/widgetConfig.ts`
2. Add widget to `DEFAULT_CONFIGURATION` array if desired:
   ```typescript
   { position: 6, widgetType: 'yourwidget' },
   ```
   Note: Default config currently has 5 slots, but can be extended

### Step 5: Handle Widget Props (If Needed)
1. Open `app/components/Dashboard.tsx`
2. Add widget-specific props to `getWidgetProps()` function if widget needs Dashboard callbacks:
   ```typescript
   if (widgetType === 'yourwidget') {
     return { onSomeEvent: handleSomeEvent };
   }
   ```

### Widget Requirements Checklist
- [ ] Widget component created in `app/components/`
- [ ] Widget type added to `WidgetType` union in `widgetRegistry.ts`
- [ ] Dynamic import added to `widgetComponents` in `widgetRegistry.ts`
- [ ] Lazy import added to `lazyWidgets` in `WidgetContainer.tsx`
- [ ] Widget uses base `Widget` component
- [ ] Widget uses `useReactiveColors()` hook for colors
- [ ] No hardcoded Tailwind green color classes
- [ ] Proper height constraints for scrolling if needed
- [ ] Widget props added to Dashboard's `getWidgetProps()` if needed
- [ ] Widget added to default configuration if desired

## Common Patterns

### Scrollable Container
```tsx
<div className="flex-1 overflow-y-auto min-h-0">
  {/* Content */}
</div>
```

### Input Field
```tsx
import { useReactiveColors } from './ColorContext';

function MyComponent() {
  const { colors } = useReactiveColors();
  
  return (
    <input
      className="
        bg-black/10
        border border-white/20
        focus:border-white/50
      "
      style={{ color: colors.primary }}
      // Placeholder automatically styled via CSS custom property
    />
  );
}
```

### Button
```tsx
import { useReactiveColors } from './ColorContext';

function MyComponent() {
  const { colors } = useReactiveColors();
  
  return (
    <button
      className="
        bg-white/10
        border border-white/30
        hover:bg-white/15
        hover:border-white/50
      "
      style={{ color: colors.button }}
    >
      Button Text
    </button>
  );
}
```

### Divider
```tsx
<div className="border-t border-white/10 pt-2" />
```

### Drag-and-Drop Reordering Pattern

When implementing drag-and-drop reordering for lists:

**State Management:**
- Track `draggedId`: The item currently being dragged
- Track `dragOverId`: The item currently being hovered over during drag
- Reset both states on `dragEnd` and `drop`

**Visual Reordering:**
- Implement `getDisplayTodos()` function that calculates the visual order during drag
- This function should reorder the array based on `draggedId` and `dragOverId`
- Render using `getDisplayTodos()` instead of the original array during drag operations
- The dragged item should appear in its new position visually, not stay in place with opacity

**Hide Browser Drag Ghost:**
- Use transparent canvas element in `handleDragStart`:
```tsx
const handleDragStart = (e: React.DragEvent, id: string) => {
  setDraggedId(id);
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', '');
  
  // Hide the default drag ghost image
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  const ctx = canvas.getContext('2d');
  if (ctx) {
    ctx.clearRect(0, 0, 1, 1);
    e.dataTransfer.setDragImage(canvas, 0, 0);
  }
};
```

**Drag Handle Pattern:**
- Use grid of dots SVG icon (3x3 circles) for drag handle
- Position handle to the left of action buttons (delete, etc.)
- Style with `cursor-grab` and `active:cursor-grabbing`
- Use reactive colors: `style={{ color: colors.secondary }}`
- Make handle `select-none` to prevent text selection

**Event Handlers:**
- `onDragStart`: Set `draggedId`, hide drag ghost
- `onDragOver`: Set `dragOverId`, prevent default
- `onDragLeave`: Minimal handling (prevent flickering)
- `onDrop`: Apply reordering, save to state/storage, reset drag states
- `onDragEnd`: Fallback to apply visual order if drag ends without drop, reset states

**Visual Feedback:**
- Dragged item: Enhanced border (`border-white/50`) and shadow (`shadow-lg`)
- Drop target: Subtle border highlight (`border-white/40`)
- Use `transition-all duration-200` for smooth animations
- Keep dragged item fully visible (no opacity reduction) - it should appear naturally in its new position

**Example Pattern:**
```tsx
const [draggedId, setDraggedId] = useState<string | null>(null);
const [dragOverId, setDragOverId] = useState<string | null>(null);

const getDisplayTodos = () => {
  if (!draggedId || !dragOverId || draggedId === dragOverId) {
    return todos;
  }
  
  const draggedIndex = todos.findIndex(todo => todo.id === draggedId);
  const targetIndex = todos.findIndex(todo => todo.id === dragOverId);
  
  if (draggedIndex === -1 || targetIndex === -1) return todos;
  
  const newTodos = [...todos];
  const [removed] = newTodos.splice(draggedIndex, 1);
  newTodos.splice(targetIndex, 0, removed);
  
  return newTodos;
};

// Render: getDisplayTodos().map(...)
```

